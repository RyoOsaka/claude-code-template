# Agent Team 開発ガイドライン

agent team 機能を使った機能開発の進め方。

## 有効化

```json
// .claude/settings.json
{
  "env": {
    "CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS": "1"
  }
}
```

## チーム構成（推奨）

機能単位でチームを編成する。1機能 = 1チーム。

```
「○○機能」チーム
├── リーダー（調整役）: デリゲートモードで調整に専念
├── 設計担当: スキーマ設計 + API 設計 + モック作成
├── バックエンド実装担当: API 実装 + API テスト
└── フロントエンド実装担当: 画面実装 + E2E テスト
```

### なぜ機能単位で分けるのか

**レイヤー単位（フロント/バック）ではなく機能単位で分ける理由:**

1. **完了の定義が明確**
   - 「ログイン機能が動く」は判定できる
   - 「フロントエンドができた」は曖昧（何が？どこまで？）

2. **責任が明確**
   - 機能単位なら「このチームの成果物」がはっきりする
   - レイヤー単位だと「フロントはできたがバックが…」と責任が曖昧になる

3. **コンテキストを保持できる**
   - 1機能のビジネスロジックを深く理解した状態で実装できる
   - レイヤー横断だと「この画面は何のため？」が薄れる

4. **PR のレビューがしやすい**
   - 「ログイン機能」で PR を作れば、レビュワーも理解しやすい
   - 機能が動く状態でマージできる（中途半端な状態を避ける）

### なぜフロント/バックで担当を分けるのか

**機能単位でチームを作りつつ、実装はフロント/バックで分ける理由:**

1. **ファイル競合を避ける**
   - 同じファイルを複数の agent が編集すると壊れやすい
   - フロント/バックなら触るファイルが明確に分離できる

2. **並列度を上げる**
   - 設計完了後、フロントとバックが同時に作業開始
   - モックがあればフロントはバックエンドを待たない

3. **AI の習熟度は人間ほど差がない**
   - 人間なら「フロント専門」「バック専門」で習熟度に差が出る
   - AI はどちらも同程度に対応可能なので、分離のデメリットが小さい

### 役割の詳細

| 役割 | 担当範囲 | 成果物 |
|------|---------|--------|
| リーダー | 全体調整、進捗管理、人間への確認 | - |
| 設計担当 | Zod スキーマ、API 設計、MSW モック | `src/schemas/`, `src/mocks/` |
| バックエンド担当 | API 実装、単体テスト | `src/routes/`, `src/services/`, `*.test.ts` |
| フロントエンド担当 | 画面実装、E2E テスト | `src/components/`, `src/pages/`, `e2e/` |

## 開発フロー

```
1. 人間: 「○○機能を作りたい」
   ↓
2. リーダー: チーム編成、設計担当を「プラン承認必須」でスポーン
   ↓
3. 設計担当: スキーマ設計 → プラン作成 → リーダーに送信
   ↓
4. リーダー → 人間: 「設計確認お願いします」
   ↓
5. 人間: 承認 or 修正指示
   ↓
6. 設計担当: スキーマ + モック作成 → 完了報告
   ↓
7. リーダー: バックエンド担当・フロントエンド担当をスポーン
   ↓
8. 並列実行:
   - バックエンド担当: API 実装 + テスト
   - フロントエンド担当: 画面実装（モック使用）+ E2E テスト
   ↓
9. 統合: フロントを実 API に接続
   ↓
10. E2E テスト: 実 API で実行
   ↓
11. リーダー → 人間: 「完了しました。確認お願いします」
   ↓
12. 人間: 確認 → チームクリーンアップ
```

## モックと実 API の使い分け

| フェーズ | モック | 実 API | 理由 |
|---------|--------|--------|------|
| フロント開発中 | ✅ | - | バックエンド完成を待たずに開発 |
| 単体テスト | ✅ | - | 速度・安定性のため |
| 統合テスト | ✅ | - | API クライアントの動作確認 |
| E2E テスト | - | ✅ | 本番同等の環境で確認 |
| 本番 | - | ✅ | - |

### ポイント

- **モック**: 開発効率のため（並列作業を可能にする）
- **実 API**: 品質保証のため（本当に動くか確認）

## 人間承認必須の項目

リーダーは以下の判断を人間に確認する:

- 認証方式の選択
- DB スキーマの設計
- 外部サービスの選定
- API の破壊的変更
- セキュリティに関わる変更

## 操作方法

### チーム作成

```
ログイン機能を作りたい。agent team を作成して。
設計担当・バックエンド担当・フロントエンド担当で進めて。
設計は人間承認必須にして。デリゲートモードで。
```

### チームメンバーとの対話

- **Shift+Up/Down**: チームメンバーを選択
- **Enter**: 選択したメンバーのセッションを表示
- **Escape**: 現在のターンを中断

### チームクリーンアップ

```
チームをクリーンアップして
```

## ファイル競合の回避

各担当が触るファイルを分離する:

| 担当 | 触るファイル |
|------|-------------|
| 設計担当 | `src/schemas/`, `src/mocks/` |
| バックエンド担当 | `src/routes/`, `src/services/`, `src/db/` |
| フロントエンド担当 | `src/components/`, `src/pages/`, `src/hooks/` |
| 共通 | `src/types/`（型定義のみ、スキーマから生成） |

## 開発方法論: ハイブリッドアプローチ

AI 駆動開発では、ウォーターフォールとアジャイルの良いとこ取りが効果的。

### なぜハイブリッドか

**純粋なウォーターフォールの問題:**
- 後半で問題が発覚すると手戻りが大きい
- AI は予測不能な挙動をすることがある

**純粋なアジャイルの問題:**
- AI は「とりあえず動くもの」を作るのは得意だが、方向性が間違うと大幅に作り直し
- 人間のレビューなしに進むと、意図と違う実装になりやすい

### ハイブリッドアプローチの原則

| フェーズ | アプローチ | 理由 |
|---------|-----------|------|
| 要件定義 | ウォーターフォール的 | 人間が明確にゴールを定義 |
| 設計 | ウォーターフォール的 | スキーマ・API 設計を事前に固める |
| 実装 | アジャイル的 | 小さな単位で実装 → 確認 → 修正 |
| レビュー | アジャイル的 | 頻繁にフィードバック |
| テスト | 両方 | 設計時にテスト方針決定、実装時に随時実行 |

### 実践ポイント

1. **設計フェーズで「何を作るか」を明確に**
   - Zod スキーマで型を先に定義
   - API エンドポイントを設計書として確定
   - モックを作成してフロントが先行開発可能に

2. **実装フェーズは小さく速く回す**
   - 1 機能ずつ実装 → テスト → レビュー
   - 動作確認を頻繁に（コンパイル通るだけでなく、実際に動かす）
   - 問題があれば即座に軌道修正

3. **人間の確認ポイントを明確に**
   - 設計完了時: 必ず承認を得る
   - 実装中: 判断が必要な場面で都度確認
   - 完了時: 最終確認

## 進捗ログ

セッション再開やエラーリカバリーのため、作業状態を定期的に記録する。

### ログファイル

`.claude/logs/progress.md` に各担当が追記する。

### 記録タイミング

- 作業開始時
- 1 タスク完了ごと
- エラー発生時（特に重要）
- 作業終了時

### フォーマット

```markdown
## YYYY-MM-DD HH:MM - [担当名]

### 完了
- 実装した内容を箇条書き

### 次のタスク
- 次にやること

### ブロッカー
- なし / あれば記載

### 未解決の問題（あれば）
- **問題**: 何が起きているか
- **試したこと**:
  1. やったこと → 結果
  2. やったこと → 結果
- **推測**: 原因の仮説
- **必要な判断**: 誰に何を確認すべきか
```

### 未解決問題の記録基準

以下の場合は「未解決の問題」として記録する:

- 同じエラーが 3 回以上続いた
- 10 分以上同じ問題で進めていない
- 設計や仕様の判断が必要

### なぜログを残すのか

1. **エラーリカバリー**: 何をやっていたか分かる → 復旧しやすい
2. **セッション再開**: 続きが分かる → 新しい agent が引き継げる
3. **ナレッジ蓄積**: 同じ問題にハマる agent を減らせる
4. **ボトルネック把握**: リーダーが問題を早期発見できる

## 注意事項

- agent team は実験的機能
- セッション再開時にチームメンバーは復元されない
- リーダーのみがチームを管理できる（ネストなし）
- チームメンバーはリーダーの権限設定を継承する
